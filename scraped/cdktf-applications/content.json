{
  "title": "Deploy an application with CDK for Terraform",
  "url": "https://developer.hashicorp.com/terraform/tutorials/cdktf/cdktf-applications",
  "codeBlocks": [
    {
      "index": 0,
      "code": "$ git clone https://github.com/hashicorp-education/learn-terraform-cdktf-applications",
      "variants": {}
    },
    {
      "index": 1,
      "code": "$ cd learn-terraform-cdktf-applications",
      "variants": {}
    },
    {
      "index": 2,
      "code": "$ docker run -d --restart always -p \"127.0.0.1:5000:5000\" --name local-registry registry:2 Unable to find image 'registry:2' locally 2: Pulling from library/registry 530afca65e2e: Already exists d450d4da0343: Pull complete 96277bea17b6: Pull complete 470ad04e03fb: Pull complete bd3d4dc6e66f: Pull complete Digest: sha256:c631a581c6152f5a4a141a974b74cf308ab2ee660287a3c749d88e0b536c0c20 Status: Downloaded newer image for registry:2 2d9c6166d2ea3b1f6ef9d933afa6069eef5e2dbaece27ce1b235b89b7c5d374b",
      "variants": {}
    },
    {
      "index": 3,
      "code": "$ kind create cluster --name=cdktf-app --config kind-config.yaml Creating cluster \"cdktf-app\" ... âœ“ Ensuring node image (kindest/node:v1.25.0) ğŸ–¼ âœ“ Preparing nodes ğŸ“¦ âœ“ Writing configuration ğŸ“œ âœ“ Starting control-plane ğŸ•¹ï¸ âœ“ Installing CNI ğŸ”Œ âœ“ Installing StorageClass ğŸ’¾ Set kubectl context to \"kind-cdktf-app\" You can now use your cluster with: kubectl cluster-info --context kind-cdktf-app Not sure what to do next? ğŸ˜… Check out https://kind.sigs.k8s.io/docs/user/quick-start/",
      "variants": {}
    },
    {
      "index": 4,
      "code": "$ kind get clusters cdktf-app",
      "variants": {}
    },
    {
      "index": 5,
      "code": "$ kubectl cluster-info --context=kind-cdktf-app Kubernetes control plane is running at https://127.0.0.1:56821 CoreDNS is running at https://127.0.0.1:56821/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.",
      "variants": {}
    },
    {
      "index": 6,
      "code": "$ kubectl config view --raw --context kind-cdktf-app > kubeconfig.yaml",
      "variants": {}
    },
    {
      "index": 7,
      "code": "$ docker network connect kind local-registry",
      "variants": {}
    },
    {
      "index": 8,
      "code": "$ kubectl apply -f local-registry-configmap.yaml --kubeconfig kubeconfig.yaml configmap/local-registry-hosting created",
      "variants": {}
    },
    {
      "index": 9,
      "code": "$ mkdir app",
      "variants": {}
    },
    {
      "index": 10,
      "code": "$ cd app",
      "variants": {}
    },
    {
      "index": 11,
      "code": "$ cdktf init --template=typescript \\ --project-name=learn-terraform-cdktf-applications \\ --project-description=\"Learn how to develop CDKTF applications\" \\ --providers=\"kubernetes@~>2.14\" \\ --local",
      "variants": {}
    },
    {
      "index": 12,
      "code": "$ cat ../k8s_deployment.tf | cdktf convert --provider=kubernetes /*Provider bindings are generated by running cdktf get. See https://cdk.tf/provider-generation for more details.*/ import * as kubernetes from \"./.gen/providers/kubernetes\"; new kubernetes.deployment.Deployment(this, \"myapp\", { metadata: { labels: { app: \"myapp\", component: \"frontend\", environment: \"dev\", }, name: \"myapp-frontend-dev\", }, spec: { replicas: \"1\", selector: { matchLabels: { app: \"myapp\", component: \"frontend\", environment: \"dev\", }, }, template: { metadata: { labels: { app: \"myapp\", component: \"frontend\", environment: \"dev\", }, }, spec: {",
      "variants": {}
    },
    {
      "index": 13,
      "code": "$ npm install path added 299 packages, and audited 357 packages in 3s 33 packages are looking for funding run `npm fund` for details found 0 vulnerabilities",
      "variants": {}
    },
    {
      "index": 14,
      "code": "$ cdktf synth Generated Terraform code for the stacks: app",
      "variants": {}
    },
    {
      "index": 15,
      "code": "$ cdktf deploy app Initializing the backend... app Successfully configured the backend \"local\"! Terraform will automatically use this backend unless the backend configuration changes. app Initializing provider plugins... app - Finding hashicorp/kubernetes versions matching \"2.14.0\"... app - Using hashicorp/kubernetes v2.14.0 from the shared cache directory ##... Plan: 1 to add, 0 to change, 0 to destroy. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Saved the plan to: plan To perform exactly these actions, run the following command to apply: terraform apply \"plan\" Please review the diff output above for app â¯ Approve Applies the changes outlined in the plan. Dismiss Stop ##... app kubernetes_deployment.myapp (myapp): Creating... app kubernetes_deployment.myapp (myapp): Creation complete after 8s [id=default/myapp] app Apply complete! Resources: 1 added, 0 changed, 0 destroyed. No outputs found.",
      "variants": {}
    },
    {
      "index": 16,
      "code": "$ kubectl get deployments NAME READY UP-TO-DATE AVAILABLE AGE myapp 1/1 1 1 117s",
      "variants": {}
    },
    {
      "index": 17,
      "code": "$ cdktf deploy app Initializing the backend... app Initializing provider plugins... app - Reusing previous version of hashicorp/kubernetes from the dependency lock file app - Using previously-installed hashicorp/kubernetes v2.14.0 app Terraform has been successfully initialized! ##... Terraform will perform the following actions: app # kubernetes_deployment.myapp (myapp) will be updated in-place ~ resource \"kubernetes_deployment\" \"myapp\" { id = \"default/myapp\" # (1 unchanged attribute hidden) ~ spec { ~ replicas = \"1\" -> \"4\" # (4 unchanged attributes hidden) # (3 unchanged blocks hidden) } # (1 unchanged block hidden) } Plan: 0 to add, 1 to change, 0 to destroy. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Saved the plan to: plan To perform exactly these actions, run the following command to apply: terraform apply \"plan\" Please review the diff output above for app â¯ Approve Applies the changes outlined in the plan.",
      "variants": {}
    },
    {
      "index": 18,
      "code": "$ kubectl get deployments NAME READY UP-TO-DATE AVAILABLE AGE myapp 4/4 4 4 8m31s",
      "variants": {}
    },
    {
      "index": 19,
      "code": "$ mkdir constructs",
      "variants": {}
    },
    {
      "index": 20,
      "code": "import { Construct } from \"constructs\" import * as kubernetes from \"@cdktf/provider-kubernetes\" export interface KubernetesWebAppDeploymentConfig { readonly image: string readonly replicas: number readonly app: string readonly component: string readonly environment: string readonly env?: Record<string, string> } export class KubernetesWebAppDeployment extends Construct { public readonly resource: kubernetes.deployment.Deployment constructor( scope: Construct,",
      "variants": {}
    },
    {
      "index": 21,
      "code": "export * from \"./kubernetes-web-app\"",
      "variants": {}
    },
    {
      "index": 22,
      "code": "import { Construct } from \"constructs\" import { App, TerraformStack } from \"cdktf\" import * as kubernetes from \"@cdktf/provider-kubernetes\" import * as path from \"path\" import { KubernetesWebAppDeployment } from \"./constructs\" class MyStack extends TerraformStack { constructor(scope: Construct, name: string) { super(scope, name) new kubernetes.provider.KubernetesProvider(this, 'kind', { configPath: path.join(__dirname, '../kubeconfig.yaml'), }) new KubernetesWebAppDeployment(",
      "variants": {}
    },
    {
      "index": 23,
      "code": "$ cdktf deploy app Initializing the backend... app Initializing provider plugins... app - Reusing previous version of hashicorp/kubernetes from the dependency lock file app - Using previously-installed hashicorp/kubernetes v2.14.0 app Terraform has been successfully initialized! ##... Plan: 1 to add, 0 to change, 1 to destroy. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Saved the plan to: plan To perform exactly these actions, run the following command to apply: terraform apply \"plan\" Please review the diff output above for app â¯ Approve Applies the changes outlined in the plan. Dismiss Stop ##... app kubernetes_deployment.myapp: Destroying... [id=default/myapp] app kubernetes_deployment.deployment_7B0B4E40 (deployment/deployment): Creating... app kubernetes_deployment.myapp: Destruction complete after 0s app kubernetes_deployment.deployment_7B0B4E40 (deployment/deployment): Creation complete after 8s [id=default/myapp-frontend-dev] app Apply complete! Resources: 1 added, 0 changed, 1 destroyed. No outputs found.",
      "variants": {}
    },
    {
      "index": 24,
      "code": "$ kubectl get deployments NAME READY UP-TO-DATE AVAILABLE AGE myapp-frontend-dev 2/2 2 2 5m14s",
      "variants": {}
    },
    {
      "index": 25,
      "code": "const cdktf = require('cdktf') cdktf.Testing.setupJest()",
      "variants": {}
    },
    {
      "index": 26,
      "code": "import \"cdktf/lib/testing/adapters/jest\" import { Testing } from \"cdktf\" import * as kubernetes from \"@cdktf/provider-kubernetes\" import { KubernetesWebAppDeployment } from \"../constructs\" describe('Our CDKTF Constructs', () => { describe('KubernetesWebAppDeployment', () => { it('should contain a deployment resource', () => { expect( Testing.synthScope((scope) => { new KubernetesWebAppDeployment(scope, 'myapp-frontend-dev', { image: 'nginx:latest', replicas: 4, app: 'myapp', component: 'frontend', environment",
      "variants": {}
    },
    {
      "index": 27,
      "code": "$ npm run test > app@1.0.0 test > jest PASS __tests__/main-test.ts PASS __tests__/kubernetes-web-app-test.ts Test Suites: 2 passed, 2 total Tests: 1 todo, 1 passed, 2 total Snapshots: 0 total Time: 5.109 s Ran all test suites.",
      "variants": {}
    },
    {
      "index": 28,
      "code": "export interface KubernetesNodePortServiceConfig { readonly port: number readonly app: string readonly component: string readonly environment: string }",
      "variants": {}
    },
    {
      "index": 29,
      "code": "export class KubernetesNodePortService extends Construct { public readonly resource: kubernetes.service.Service constructor( scope: Construct, name: string, config: KubernetesNodePortServiceConfig ) { super(scope, name) this.resource = new kubernetes.service.Service(this, name, { metadata: { name: `${config.app}-${config.component}-${config.environment}`, },",
      "variants": {}
    },
    {
      "index": 30,
      "code": "describe('KubernetesNodePortService', () => { it('should contain a Service resource', () => { expect( Testing.synthScope((scope) => { new KubernetesNodePortService(scope, 'myapp-frontend-dev', { app: 'myapp', component: 'frontend', environment: 'dev', port: 30001, }) }) ).toHaveResource(kubernetes.service.Service) }) })",
      "variants": {}
    },
    {
      "index": 31,
      "code": "$ npm run test > app@1.0.0 test > jest PASS __tests__/main-test.ts PASS __tests__/kubernetes-web-app-test.ts Test Suites: 2 passed, 2 total Tests: 1 todo, 2 passed, 3 total Snapshots: 0 total Time: 5.094 s Ran all test suites.",
      "variants": {}
    },
    {
      "index": 32,
      "code": "new KubernetesNodePortService(this, 'service', { port: 30001, app: 'myapp', component: 'frontend', environment: 'dev', })",
      "variants": {}
    },
    {
      "index": 33,
      "code": "$ cdktf deploy app Initializing the backend... app Initializing provider plugins... app - Reusing previous version of hashicorp/kubernetes from the dependency lock file app - Using previously-installed hashicorp/kubernetes v2.14.0 app Terraform has been successfully initialized! ##... Plan: 1 to add, 0 to change, 0 to destroy. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Saved the plan to: plan To perform exactly these actions, run the following command to apply: terraform apply \"plan\" Please review the diff output above for app â¯ Approve Applies the changes outlined in the plan. Dismiss Stop ##... app kubernetes_service.service_E7C408F2 (service/service): Creating... app kubernetes_service.service_E7C408F2 (service/service): Creation complete after 0s [id=default/myapp-frontend-dev] app Apply complete! Resources: 1 added, 0 changed, 0 destroyed. No outputs found.",
      "variants": {}
    },
    {
      "index": 34,
      "code": "$ kubectl get services NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.96.0.1 <none> 443/TCP 101m myapp-frontend-dev NodePort 10.96.186.212 <none> 80:30001/TCP 22s",
      "variants": {}
    },
    {
      "index": 35,
      "code": "$ curl http://localhost:30001 <!DOCTYPE html> <html> <head> <title>Welcome to nginx!</title> <style> html { color-scheme: light dark; } body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } </style> </head> <body> <h1>Welcome to nginx!</h1> <p>If you see this page, the nginx web server is successfully installed and working. Further configuration is required.</p> <p>For online documentation and support please refer to <a href=\"http://nginx.org/\">nginx.org</a>.<br/> Commercial support is available at <a href=\"http://nginx.com/\">nginx.com</a>.</p> <p><em>Thank you for using nginx.</em></p> </body> </html>",
      "variants": {}
    },
    {
      "index": 36,
      "code": "$ cdktf destroy app Initializing the backend... app Initializing provider plugins... app - Reusing previous version of hashicorp/kubernetes from the dependency lock file app - Using previously-installed hashicorp/kubernetes v2.14.0 app Terraform has been successfully initialized! ##... Plan: 0 to add, 0 to change, 2 to destroy. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Saved the plan to: plan To perform exactly these actions, run the following command to apply: terraform apply \"plan\" Please review the diff output above for app â¯ Approve Applies the changes outlined in the plan. Dismiss Stop app kubernetes_service.service_E7C408F2 (service/service): Destroying... [id=default/myapp-frontend-dev] app kubernetes_deployment.deployment_7B0B4E40 (deployment/deployment): Destroying... [id=default/myapp-frontend-dev] app kubernetes_deployment.deployment_7B0B4E40 (deployment/deployment): Destruction complete after 0s app kubernetes_service.service_E7C408F2 (service/service): Destruction complete after 0s app Destroy complete! Resources: 2 destroyed.",
      "variants": {}
    },
    {
      "index": 37,
      "code": "import { TerraformOutput } from \"cdktf\"",
      "variants": {}
    },
    {
      "index": 38,
      "code": "export type SimpleKubernetesWebAppConfig = KubernetesWebAppDeploymentConfig & KubernetesNodePortServiceConfig export class SimpleKubernetesWebApp extends Construct { public readonly deployment: KubernetesWebAppDeployment public readonly service: KubernetesNodePortService public readonly config: SimpleKubernetesWebAppConfig constructor( scope: Construct, name: string, config: SimpleKubernetesWebAppConfig ) { super(scope, name) this.config = config this.deployment = new KubernetesWebAppDeployment(this, 'deployment', { image: config",
      "variants": {}
    },
    {
      "index": 39,
      "code": "describe('SimpleKubernetesWebApp', () => { it('should contain a Service resource', () => { expect( Testing.synthScope((scope) => { new SimpleKubernetesWebApp(scope, 'myapp-frontend-dev', { image: 'nginx:latest', replicas: 4, app: 'myapp', component: 'frontent', environment: 'dev', port: 30001, }) }) ).toHaveResource(kubernetes.service.Service) }) it('should contain a Deployment resource', () =>",
      "variants": {}
    },
    {
      "index": 40,
      "code": "$ npm run test > app@1.0.0 test > jest PASS __tests__/main-test.ts (6.019 s) PASS __tests__/kubernetes-web-app-test.ts (8.059 s) Test Suites: 2 passed, 2 total Tests: 1 todo, 4 passed, 5 total Snapshots: 0 total Time: 8.556 s Ran all test suites.",
      "variants": {}
    },
    {
      "index": 41,
      "code": "import { SimpleKubernetesWebApp } from \"./constructs\"",
      "variants": {}
    },
    {
      "index": 42,
      "code": "new SimpleKubernetesWebApp(this, 'app_frontend', { image: 'nginx:latest', replicas: 3, port: 30001, app: 'myapp', component: 'frontend', environment: 'dev', })",
      "variants": {}
    },
    {
      "index": 43,
      "code": "$ cdktf deploy app Initializing the backend... app Initializing provider plugins... app - Reusing previous version of hashicorp/kubernetes from the dependency lock file app - Using previously-installed hashicorp/kubernetes v2.14.0 app Terraform has been successfully initialized! ##... Plan: 2 to add, 0 to change, 0 to destroy. Changes to Outputs: + app_frontend_url_5DD99814 = \"http://localhost:30001\" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Saved the plan to: plan To perform exactly these actions, run the following command to apply: terraform apply \"plan\" Please review the diff output above for app â¯ Approve Applies the changes outlined in the plan. Dismiss Stop app kubernetes_service.app_frontend_service_C2863249 (app_frontend/service/service): Creating... app kubernetes_deployment.app_frontend_deployment_0EE98C72 (app_frontend/deployment/deployment): Creating... app kubernetes_service.app_frontend_service_C2863249 (app_frontend/service/service): Creation complete after 0s [id=default/myapp-frontend-dev] app kubernetes_deployment.app_frontend_deployment_0EE98C72 (app_frontend/deployment/deployment): Creation complete after 4s [id=default/myapp-frontend-dev] app Apply complete! Resources: 2 added, 0 changed, 0 destroyed. app Outputs: app_frontend_url_5DD99814 = \"http://localhost:30001\"",
      "variants": {}
    },
    {
      "index": 44,
      "code": "$ kubectl get services NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.96.0.1 <none> 443/TCP 142m myapp-frontend-dev NodePort 10.96.216.88 <none> 80:30001/TCP 44s",
      "variants": {}
    },
    {
      "index": 45,
      "code": "$ curl http://localhost:30001 <!DOCTYPE html> <html> <head> <title>Welcome to nginx!</title> <style> html { color-scheme: light dark; } body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } </style> </head> <body> <h1>Welcome to nginx!</h1> <p>If you see this page, the nginx web server is successfully installed and working. Further configuration is required.</p> <p>For online documentation and support please refer to <a href=\"http://nginx.org/\">nginx.org</a>.<br/> Commercial support is available at <a href=\"http://nginx.com/\">nginx.com</a>.</p> <p><em>Thank you for using nginx.</em></p> </body> </html>",
      "variants": {}
    },
    {
      "index": 46,
      "code": "$ cd ../frontend",
      "variants": {}
    },
    {
      "index": 47,
      "code": "$ docker build . -t nocorp-frontend [+] Building 33.0s (12/12) FINISHED => [internal] load build definition from Dockerfile 0.0s => => transferring dockerfile: 295B 0.0s => [internal] load .dockerignore 0.0s => => transferring context: 67B 0.0s => [internal] load metadata for docker.io/library/node:14 1.3s => [1/7] FROM docker.io/library/node:14@sha256:109b118e0d49dd12ca6f5b84a7a9a9c8a147f75567b3ad50620bdacaf5e6320d 26.2s ## ... => [internal] load build context 0.0s => => transferring context: 718.44kB 0.0s => [2/7] WORKDIR /usr/share/app 0.2s => [3/7] COPY package*.json ./ 0.0s => [4/7] COPY frontend.js ./ 0.0s => [5/7] COPY public/ ./public/ 0.0s => [6/7] COPY views/ ./views/ 0.0s => [7/7] RUN npm install 4.8s => exporting to image 0.2s => => exporting layers 0.2s => => writing image sha256:9dc1ce3668a79770f694ddeae6a5c2236527c381cd429d850eb4a37a8c565ce1 0.0s => => naming to docker.io/library/nocorp-frontend 0.0s Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them",
      "variants": {}
    },
    {
      "index": 48,
      "code": "$ docker tag nocorp-frontend:latest localhost:5000/nocorp-frontend:latest",
      "variants": {}
    },
    {
      "index": 49,
      "code": "$ docker push localhost:5000/nocorp-frontend:latest The push refers to repository [localhost:5000/nocorp-frontend] 72d21ab0ed02: Pushed a831dca05db6: Pushed 66018b4c7669: Pushed 65f4bcfe9daa: Pushed add6fa0cc975: Pushed 8628cf05347a: Pushed 85bfe2c7cf32: Pushed 28e2f0d3695c: Pushed b892edc3d92e: Pushed f1486e967e48: Pushed 5750262417ad: Pushed 9ed3c35b4335: Pushed 6f7f3f280040: Pushed d6e0d602719c: Pushed 73c3e7ef7bc6: Pushed latest: digest: sha256:f56babe32077523e891b24af0e38fe00026c7f8ed38b89d90a102aaeeb3d40b8 size: 3465",
      "variants": {}
    },
    {
      "index": 50,
      "code": "$ cd ../app",
      "variants": {}
    },
    {
      "index": 51,
      "code": "$ cdktf deploy app Initializing the backend... app Initializing provider plugins... app - Reusing previous version of hashicorp/kubernetes from the dependency lock file app - Using previously-installed hashicorp/kubernetes v2.14.0 Terraform has been successfully initialized! ##... app Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols: ~ update in-place Terraform will perform the following actions: app # kubernetes_deployment.app_frontend_deployment_0EE98C72 (app_frontend/deployment/deployment) will be updated in-place ~ resource \"kubernetes_deployment\" \"app_frontend_deployment_0EE98C72\" { id = \"default/myapp-frontend-dev\" # (1 unchanged attribute hidden) ~ spec { # (5 unchanged attributes hidden) ~ template { ~ spec { # (11 unchanged attributes hidden) ~ container { ~ image = \"nginx:latest\" -> \"localhost:5000/nocorp-frontend:latest\" name = \"myapp-frontend-dev\" # (8 unchanged attributes hidden) ##... Plan: 0 to add, 1 to change, 0 to destroy. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
      "variants": {}
    },
    {
      "index": 52,
      "code": "$ kubectl get deployments NAME READY UP-TO-DATE AVAILABLE AGE myapp-frontend-dev 3/3 3 3 43s",
      "variants": {}
    },
    {
      "index": 53,
      "code": "$ curl http://localhost:30001 <!DOCTYPE html><html><head><title>Terranimo</title></head><link rel=\"stylesheet\" href=\"/styles/terramino.css\"></html><body><div class=\"score\" id=\"score\"></div><div class=\"container\"><div class=\"content\"><h1>Terramino</h1><p class=\"error\" id=\"errorMessage\">Could not connect to server! <br/> Reload to try again.</p><p>Move: â† â†’ Rotate: â†‘ Drop: â†“</p></div><div class=\"content\"><canvas width=\"320\" height=\"640\" id=\"game\"></canvas></div></div><script src=\"/scripts/terramino.js\"></script><script>start('http://localhost:30002')</script></body>",
      "variants": {}
    },
    {
      "index": 54,
      "code": "$ cd ../backend",
      "variants": {}
    },
    {
      "index": 55,
      "code": "$ npm run deploy > nocorp-backend-app@1.0.0 deploy /Users/<YOU>/code/learn-terraform-cdktf-applications/backend > npm run build && npm run tag && npm run push > nocorp-backend-app@1.0.0 build /Users/<YOU>/code/learn-terraform-cdktf-applications/backend > docker build . -t nocorp-backend ## ... The push refers to repository [localhost:5000/nocorp-backend] 676744aedcf3: Pushed e64b93b2c9bd: Pushed 8628cf05347a: Mounted from nocorp-frontend 85bfe2c7cf32: Mounted from nocorp-frontend 28e2f0d3695c: Mounted from nocorp-frontend b892edc3d92e: Mounted from nocorp-frontend f1486e967e48: Mounted from nocorp-frontend 5750262417ad: Mounted from nocorp-frontend 9ed3c35b4335: Mounted from nocorp-frontend 6f7f3f280040: Mounted from nocorp-frontend d6e0d602719c: Mounted from nocorp-frontend 73c3e7ef7bc6: Mounted from nocorp-frontend latest: digest: sha256:845e60dd8350066a89757f1bdb200584f317e5b15d68cc9609a3c359f3736676 size: 2841",
      "variants": {}
    },
    {
      "index": 56,
      "code": "const app_backend = new SimpleKubernetesWebApp(this, 'app_backend', { image: 'localhost:5000/nocorp-backend:latest', replicas: 1, port: 30002, app: 'myapp', component: 'backend', environment: 'dev', })",
      "variants": {}
    },
    {
      "index": 57,
      "code": "$ cd ../app",
      "variants": {}
    },
    {
      "index": 58,
      "code": "$ cdktf deploy app Initializing the backend... app Initializing provider plugins... - Reusing previous version of hashicorp/kubernetes from the dependency lock file app - Using previously-installed hashicorp/kubernetes v2.14.0 Terraform has been successfully initialized! ##... app Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols: + create ~ update in-place Terraform will perform the following actions: app # kubernetes_deployment.app_backend_deployment_1A8B5520 (app_backend/deployment/deployment) will be created + resource \"kubernetes_deployment\" \"app_backend_deployment_1A8B5520\" { ##... # kubernetes_deployment.app_frontend_deployment_0EE98C72 (app_frontend/deployment/deployment) will be updated in-place ~ resource \"kubernetes_deployment\" \"app_frontend_deployment_0EE98C72\" { id = \"default/myapp-frontend-dev\" ##... + env { + name = \"BACKEND_APP_URL\" + value = \"http://localhost:30002\" } ##... # kubernetes_service.app_backend_service_EAD583EF (app_backend/service/service) will be created + resource \"kubernetes_service\" \"app_backend_service_EAD583EF\" { ##... Plan: 2 to add, 1 to change, 0 to destroy. Changes to Outputs: + app_backend_url_CAA2B50B = \"http://localhost:30002\"",
      "variants": {}
    },
    {
      "index": 59,
      "code": "$ kubectl get deployments NAME READY UP-TO-DATE AVAILABLE AGE myapp-backend-dev 1/1 1 1 57s myapp-frontend-dev 3/3 3 3 15m",
      "variants": {}
    },
    {
      "index": 60,
      "code": "$ curl http://localhost:30002/new {\"game\":{\"id\":\"pdSW6Cymw\",\"state\":\"running\",\"score\":0,\"tetrominoSequence\":[\"I\",\"J\",\"Z\",\"O\",\"T\",\"S\"]},\"tetromino\":\"L\"}",
      "variants": {}
    },
    {
      "index": 61,
      "code": "class MyStack extends TerraformStack { constructor( scope: Construct, name: string, config: { frontend: SimpleKubernetesWebAppConfig backend: SimpleKubernetesWebAppConfig } ) { super(scope, name) new kubernetes.provider.KubernetesProvider(this, 'kind', { configPath: path.join(__dirname, '../kubeconfig.yaml'), }) const app_backend = new SimpleKubernetesWebApp( this, 'app_backend', config",
      "variants": {}
    },
    {
      "index": 62,
      "code": "$ cdktf deploy app Initializing the backend... app Initializing provider plugins... - Reusing previous version of hashicorp/kubernetes from the dependency lock file app - Using previously-installed hashicorp/kubernetes v2.14.0 app Terraform has been successfully initialized! ##... app No changes. Your infrastructure matches the configuration. app Terraform has compared your real infrastructure against your configuration and found no differences, so no changes are needed. app app_frontend url = http://localhost:30001 app_backend url = http://localhost:30002",
      "variants": {}
    },
    {
      "index": 63,
      "code": "new MyStack(app, 'app-test', { frontend: { image: 'localhost:5000/nocorp-frontend:latest', replicas: 4, port: 30003, app: 'myapp', component: 'frontend', environment: 'test', }, backend: { image: 'localhost:5000/nocorp-backend:latest', replicas: 2, port: 30004, app: 'myapp', component: 'backend', environment: 'test', },",
      "variants": {}
    },
    {
      "index": 64,
      "code": "$ cdktf deploy app-test app-test Initializing the backend... app-test Successfully configured the backend \"local\"! Terraform will automatically use this backend unless the backend configuration changes. app-test Initializing provider plugins... - Finding hashicorp/kubernetes versions matching \"2.14.0\"... app-test - Using hashicorp/kubernetes v2.14.0 from the shared cache directory app-test Terraform has created a lock file .terraform.lock.hcl to record the provider selections it made above. Include this file in your version control repository so that Terraform can guarantee to make the same selections by default when you run \"terraform init\" in the future. ##... Please review the diff output above for app â¯ Approve Applies the changes outlined in the plan. Dismiss Stop ##... app-test kubernetes_service.app_frontend_service_C2863249 (app_frontend/service/service): Creating... kubernetes_service.app_backend_service_EAD583EF (app_backend/service/service): Creating... app-test kubernetes_deployment.app_backend_deployment_1A8B5520 (app_backend/deployment/deployment): Creating... app-test kubernetes_deployment.app_frontend_deployment_0EE98C72 (app_frontend/deployment/deployment): Creating... app-test kubernetes_service.app_frontend_service_C2863249 (app_frontend/service/service): Creation complete after 0s [id=default/myapp-frontend-test] app-test kubernetes_service.app_backend_service_EAD583EF (app_backend/service/service): Creation complete after 0s [id=default/myapp-backend-test] app-test kubernetes_deployment.app_frontend_deployment_0EE98C72 (app_frontend/deployment/deployment): Creation complete after 8s [id=default/myapp-frontend-test] app-test kubernetes_deployment.app_backend_deployment_1A8B5520 (app_backend/deployment/deployment): Creation complete after 8s [id=default/myapp-backend-test] app-test Apply complete! Resources: 4 added, 0 changed, 0 destroyed. app-test Outputs:",
      "variants": {}
    },
    {
      "index": 65,
      "code": "$ kubectl get deployments NAME READY UP-TO-DATE AVAILABLE AGE myapp-backend-dev 1/1 1 1 46m myapp-backend-test 2/2 2 2 71s myapp-frontend-dev 3/3 3 3 60m myapp-frontend-test 4/4 4 4 71s",
      "variants": {}
    },
    {
      "index": 66,
      "code": "$ cdktf destroy app-test app-test Initializing the backend... app-test Initializing provider plugins... - Reusing previous version of hashicorp/kubernetes from the dependency lock file app-test - Using previously-installed hashicorp/kubernetes v2.14.0 app-test Terraform has been successfully initialized! ##... Plan: 0 to add, 0 to change, 4 to destroy. app-test Changes to Outputs: - app_backend_url_CAA2B50B = \"http://localhost:30004\" -> null - app_frontend_url_5DD99814 = \"http://localhost:30003\" -> null â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Saved the plan to: plan To perform exactly these actions, run the following command to apply: terraform apply \"plan\" Please review the diff output above for app-test â¯ Approve Applies the changes outlined in the plan. Dismiss Stop ##... app-test kubernetes_service.app_backend_service_EAD583EF (app_backend/service/service): Destruction complete after 0s app-test kubernetes_service.app_frontend_service_C2863249 (app_frontend/service/service): Destruction complete after 0s app-test Destroy complete! Resources: 4 destroyed.",
      "variants": {}
    },
    {
      "index": 67,
      "code": "$ cdktf destroy app app Initializing the backend... app Initializing provider plugins... - Reusing previous version of hashicorp/kubernetes from the dependency lock file app - Using previously-installed hashicorp/kubernetes v2.12.1 app Terraform has been successfully initialized! ##... Plan: 0 to add, 0 to change, 4 to destroy. Changes to Outputs: - app_frontend_url_FE3D723A = \"http://localhost:30001\" -> null - app_backend_url_91B41C22 = \"http://localhost:30002\" -> null â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Saved the plan to: plan To perform exactly these actions, run the following command to apply: terraform apply \"plan\" Please review the diff output above for app â¯ Approve Applies the changes outlined in the plan. Dismiss Stop ##... app kubernetes_service.app_backend_service_EAD583EF (app_backend/service/service): Destruction complete after 0s app kubernetes_service.app_frontend_service_C2863249 (app_frontend/service/service): Destruction complete after 0s app Destroy complete! Resources: 4 destroyed.",
      "variants": {}
    },
    {
      "index": 68,
      "code": "$ kind delete cluster --name=cdktf-app Deleting cluster \"cdktf-app\" ...",
      "variants": {}
    },
    {
      "index": 69,
      "code": "$ docker stop local-registry local-registry",
      "variants": {}
    },
    {
      "index": 70,
      "code": "$ docker rm local-registry local-registry",
      "variants": {}
    }
  ],
  "sections": [
    {
      "heading": "20min",
      "level": 1,
      "prose": "Terraform Interactive The Cloud Development Kit for Terraform (CDKTF) allows you to define infrastructure using familiar programming languages such as TypeScript, Python, or Go. This lets you take advantage of the existing library of providers and modules in the Terraform ecosystem. Terraform configuration language is a declarative configuration language with functions and constructs that let you manage infrastructure. CDKTF allows you to generate Terraform configuration by writing code in your preferred programming language, with the same tools and workflows as your application code. Using CDKTF allows you to integrate your infrastructure management process with your testing and application deployment pipelines, which makes it easer for developers to work with their own infrastructure. In this tutorial, you will use the CDK for Terraform to deploy an application on Kubernetes. First, you will use CDKTF to convert Terraform configuration into TypeScript code. Then, you will refactor your code to dynamically generate Terraform configuration to manage an example web application consisting of frontend and backend services. Next, you will create multiple stacks representing the application in different environments. Finally, you will use CDKTF to remove your application. Prerequisites This tutorial assumes that you are familiar with the standard Terraform workflow. If you are new to Terraform, complete the Get Started tutorials first. For this tutorial, you will need: Terraform v1.2+ CDK for Terraform v0.15+ Docker Desktop installed and running. NPM (v8.19+) and NodeJS (v18+) installed. kubectl kind Launch Terminal This tutorial includes a free interactive command-line lab that lets you follow along on actual cloud infrastructure. Clone example repository Clone the CDKTF Applications GitHub repository for this tutorial. git clone https://github.com/hashicorp-education/learn-terraform-cdktf-applications Change to the repository directory. cd learn-terraform-cdktf-applications This repository contains an example application with frontend and a backend services that you will deploy on Kubernetes as Docker containers. It also contains configuration files that you will use to create a local Kubernetes cluster with kind. Configure local Kubernetes cluster Start a local Docker registry to store the container images you will use in this tutorial. docker run -d --restart always -p --name local-registry registry:2 Unable to find image 'registry:2' locally 2: Pulling from library/registry 530afca65e2e: Already exists d450d4da0343: Pull complete 96277bea17b6: Pull complete 470ad04e03fb: Pull complete bd3d4dc6e66f: Pull complete Digest: sha256:c631a581c6152f5a4a141a974b74cf308ab2ee660287a3c749d88e0b536c0c20 Status: Downloaded newer image for registry:2 2d9c6166d2ea3b1f6ef9d933afa6069eef5e2dbaece27ce1b235b89b7c5d374b Use kind to create a Kubernetes cluster running in Docker on your local machine. kind create cluster --name=cdktf-app --config kind-config.yaml Creating cluster âœ“ Ensuring node image (kindest/node:v1.25.0) ğŸ–¼ âœ“ Preparing nodes ğŸ“¦ âœ“ Writing configuration ğŸ“œ âœ“ Starting control-plane ğŸ•¹ï¸ âœ“ Installing CNI ğŸ”Œ âœ“ Installing StorageClass ğŸ’¾ Set kubectl context to You can now use your cluster with: kubectl cluster-info --context kind-cdktf-app Not sure what to do next? ğŸ˜…  Check out https://kind.sigs.k8s.io/docs/user/quick-start/ Verify that your cluster exists by listing your kind clusters. kind get clusters cdktf-app Then, use kubectl to print out information about your cluster. The context is kind- followed by the name of your cluster. kubectl cluster-info --context=kind-cdktf-app Kubernetes control plane is running at https://127.0.0.1:56821 CoreDNS is running at https://127.0.0.1:56821/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'. Create a kubeconfig file to allow access to your Kubernetes cluster. kubectl config view --raw --context kind-cdktf-app kubeconfig.yaml Now, attach your local Docker registry to your kind cluster. docker network connect kind local-registry Configure your Kubernetes cluster to use the local registry. kubectl apply -f local-registry-configmap.yaml --kubeconfig kubeconfig.yaml configmap/local-registry-hosting created Your Kubernetes cluster now uses the local Docker registry to store and retrieve Docker images. Next you will use CDKTF to generate images for your application and deploy them to your cluster. Initialize your CDKTF application Create a directory for your CDKTF application. mkdir app Now change into it. cd app Initialize your CDKTF application with the typescript template and a pre-built Kubernetes provider. For this tutorial, use the --local flag so that CDKTF stores your Terraform state locally, rather than in a remote backend such as HCP Terraform. cdktf init --template=typescript \\ --project-name=learn-terraform-cdktf-applications \\ --project-description= --providers= --local When CDKTF prompts you, accept the defaults. CDKTF will initialize your application in the current directory, and print out a help message. Note: By supplying '--local' option you have chosen local storage mode for storing the state of your stack. This means that your Terraform state file will be stored locally on disk in a file 'terraform.<STACK NAME>.tfstate' in the root of your project. ? Do you want to start from an existing Terraform project? No ? Do you want to send crash reports to the CDKTF team? See https://www.terraform.io/cdktf/create-and-deploy/configuration-file#enable-crash -reporting-for-the-cli for more information Yes ##... Use Providers: You can add prebuilt providers (if available) or locally generated ones using the add command: cdktf provider add You can find all prebuilt providers on npm: https://www.npmjs.com/search?q=keywords:cdktf You can also install these providers directly through npm: npm install @cdktf/provider-aws npm install @cdktf/provider-google npm install @cdktf/provider-azurerm npm install @cdktf/provider-docker npm install @cdktf/provider-github npm install @cdktf/provider-null You can also build any module or provider locally. Learn more https://cdk.tf/modules-and-providers ======================================================================================================== Checking whether pre-built provider exists for the following constraints: provider: kubernetes version : ~>2.14 language: typescript cdktf   : 0.15.0 Found pre-built provider. Adding package @cdktf/provider-kubernetes @ 3.0.12 Installing package @cdktf/provider-kubernetes @ 3.0.12 using npm. Package installed. CDKTF created your application from a template. Create a Kubernetes Deployment Now that you have initialized your CDKTF application, create a Kubernetes Deployment for your application's frontend. Add Kubernetes Deployment Convert example Terraform configuration that defines a Kubernetes Deployment into TypeScript. cat ../k8s_deployment.tf cdktf convert --provider=kubernetes /*Provider bindings are generated by running cdktf get. See https://cdk.tf/provider-generation for more details.*/ import * as kubernetes from new kubernetes.deployment.Deployment(this, metadata: { labels: { app: component: environment: }, name: }, spec: { replicas: selector: { matchLabels: { app: component: environment: }, }, template: { metadata: { labels: { app: component: environment: }, }, spec: { container: [ image: name: }, ], }, }, }, }); The cdktf convert command converts Terraform configuration into code in the project's configured programming language. This command is still experimental, so this output requires some adjustment before you can use it in your project. Open main.ts and add code to import the Kubernetes provider and path, and define a deployment. main.ts import { Construct } from import { App TerraformStack } from import as kubernetes from import as path from class MyStack extends TerraformStack constructor (scope Construct name string ) { super (scope name) new kubernetes provider .KubernetesProvider this 'kind' configPath path .join (__dirname '../kubeconfig.yaml' }) new kubernetes deployment .Deployment this metadata labels app 'myapp' component 'frontend' environment 'dev' name 'myapp' spec replicas '1' selector matchLabels app 'myapp' component 'frontend' environment 'dev' template metadata labels app 'myapp' component 'frontend' environment 'dev' spec container image 'nginx:latest' name 'frontend' }) const app new App () new MyStack (app 'app' app .synth () This code adds a Kubernetes provider configured with the kubeconfig.yml file you created earlier, and a new kubernetes.Deployment object that represents a Kubernetes Deployment consisting of a single pod running the nginx:latest image. Install dependencies Install the path package with NPM. npm install path added 299 packages, and audited 357 packages in 3s 33 packages are looking for funding run `npm fund` for details found 0 vulnerabilities Synthesize your application Use the cdktf synth command to generate Terraform configuration from your code. cdktf synth Generated Terraform code for the stacks: app In your text editor, review the contents of app/cdktf.out/stacks/app/cdk.tf.json . This is Terraform configuration in JSON format that CDKTF generated based on your TypeScript code in main.ts Deploy your app The cdktf deploy command will use Terraform to apply the configuration generated by cdktf synth Create your Kubernetes Deployment with cdktf deploy . Respond to the confirmation prompt with Approve cdktf deploy app  Initializing the backend... app Successfully configured the backend use this backend unless the backend configuration changes. app  Initializing provider plugins... app  - Finding hashicorp/kubernetes versions matching app  - Using hashicorp/kubernetes v2.14.0 from the shared cache directory ##... Plan: 1 to add, 0 to change, 0 to destroy. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Saved the plan to: plan To perform exactly these actions, run the following command to apply: terraform apply Please review the diff output above for app Approve  Applies the changes outlined in the plan. Dismiss Stop ##... app  kubernetes_deployment.myapp (myapp): Creating... app  kubernetes_deployment.myapp (myapp): Creation complete after 8s [id=default/myapp] app Apply complete! Resources: 1 added, 0 changed, 0 destroyed. No outputs found. The deploy command synthesizes your Terraform configuration if needed, so you will skip cdktf synth for the rest of the tutorial. List your deployments with kubectl kubectl get deployments NAME    READY   UP-TO-DATE   AVAILABLE   AGE myapp   1/1     1            1           117s Update replica count As with Terraform, you can use CDKTF to update your existing resources. In your editor, update main.ts to change the number of replicas for your deployment from to main.ts spec: { replicas: '1', replicas: '4', selector: { Deploy your application again. Respond to the confirmation prompt by choosing Approve cdktf deploy app  Initializing the backend... app  Initializing provider plugins... app  - Reusing previous version of hashicorp/kubernetes from the dependency lock file app  - Using previously-installed hashicorp/kubernetes v2.14.0 app  Terraform has been successfully initialized! ##... Terraform will perform the following actions: app    # kubernetes_deployment.myapp (myapp) will be updated in-place ~ resource id               = # (1 unchanged attribute hidden) ~ spec { ~ replicas                  = # (4 unchanged attributes hidden) # (3 unchanged blocks hidden) # (1 unchanged block hidden) Plan: 0 to add, 1 to change, 0 to destroy. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Saved the plan to: plan To perform exactly these actions, run the following command to apply: terraform apply Please review the diff output above for app Approve  Applies the changes outlined in the plan. Dismiss Stop ##... app  kubernetes_deployment.myapp (myapp): Modifying... [id=default/myapp] app  kubernetes_deployment.myapp (myapp): Modifications complete after 4s [id=default/myapp] app Apply complete! Resources: 0 added, 1 changed, 0 destroyed. No outputs found. After Kubernetes finishes applying this change, kubectl will report four instances of your applicaton. kubectl get deployments NAME    READY   UP-TO-DATE   AVAILABLE   AGE myapp   4/4     4            4           8m31s Refactor your deployment CDKTF applications are made up of constructs which represent the infrastruture CDKTF will manage for you. You can extend the Construct class to define your own constructs. This way, you can create reusable components that will make up your application infrastructure. Create construct Refactor your Deployment using a CDKTF construct. Create a new directory for your constructs inside the learn-terraform-cdktf-applications/app directory. mkdir constructs Inside the constructs directory, create a new file named kubernetes-web-app.ts for the Kubernetes web application constructs you will create in this tutorial. constructs/kubernetes-web-app.ts import { Construct } from import as kubernetes from export interface KubernetesWebAppDeploymentConfig readonly image string readonly replicas number readonly app string readonly component string readonly environment string readonly env ?: Record string string export class KubernetesWebAppDeployment extends Construct public readonly resource kubernetes deployment Deployment constructor scope Construct name string config KubernetesWebAppDeploymentConfig ) { super (scope name) this .resource new kubernetes deployment .Deployment this name metadata labels app config .app component config .component environment config .environment name ${ config .app ${ config .component ${ config .environment spec replicas config replicas .toString () selector matchLabels app config .app component config .component environment config .environment template metadata labels app config .app component config .component environment config .environment spec container image config .image name ${ config .app ${ config .component ${ config .environment env Object .entries config .env || {}) .map (([name value]) => ({ name value })) }) This code imports the Construct base class, as well as the Kubernetes provider library you installed earlier. Then, it defines an interface you will use to configure your web application deployments. Finally, it defines a class named KubernetesWebAppDeployment which extends the Construct base class to define and configure the Kubernetes Deployments you will use to manage the web application for this tutorial. Create a file in the constructs directory named index.ts , with the following contents to export the classes and interfaces you define in kubernetes-web-app.ts constructs/index.ts export from Add Deployment construct to CDKTF application Open app/main.ts and import your new Construct near top of the file. main.ts import { Construct } from import { App TerraformStack } from import as kubernetes from import as path from import { KubernetesWebAppDeployment } from Replace the entire new kubernetes.deployment.Deployment(this, block with a new instance of your construct. main.ts class MyStack extends TerraformStack constructor (scope Construct name string ) { super (scope name) new kubernetes provider .KubernetesProvider this 'kind' configPath path .join (__dirname '../kubeconfig.yaml' }) new KubernetesWebAppDeployment this 'deployment' image 'nginx:latest' replicas app 'myapp' component 'frontend' environment 'dev' }) Tip Be sure to replace the entire kubernetes.deployment.Deployment block. If you get stuck editing the file, replace the entire file with the code below. Now main.ts will contain: main.ts import { Construct } from import { App TerraformStack } from import as kubernetes from import as path from import { KubernetesWebAppDeployment } from class MyStack extends TerraformStack constructor (scope Construct name string ) { super (scope name) new kubernetes provider .KubernetesProvider this 'kind' configPath path .join (__dirname '../kubeconfig.yaml' }) new KubernetesWebAppDeployment this 'deployment' image 'nginx:latest' replicas app 'myapp' component 'frontend' environment 'dev' }) const app new App () new MyStack (app 'app' app .synth () Deploy your application. This will reduce the number of replicas for your deployment from four to two, as specified in the arguments to KubernetesWebAppDeployment . Respond to the confirmation prompt by choosing Approve cdktf deploy app  Initializing the backend... app  Initializing provider plugins... app  - Reusing previous version of hashicorp/kubernetes from the dependency lock file app  - Using previously-installed hashicorp/kubernetes v2.14.0 app  Terraform has been successfully initialized! ##... Plan: 1 to add, 0 to change, 1 to destroy. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Saved the plan to: plan To perform exactly these actions, run the following command to apply: terraform apply Please review the diff output above for app Approve  Applies the changes outlined in the plan. Dismiss Stop ##... app  kubernetes_deployment.myapp: Destroying... [id=default/myapp] app  kubernetes_deployment.deployment_7B0B4E40 (deployment/deployment): Creating... app  kubernetes_deployment.myapp: Destruction complete after 0s app  kubernetes_deployment.deployment_7B0B4E40 (deployment/deployment): Creation complete after 8s [id=default/myapp-frontend-dev] app Apply complete! Resources: 1 added, 0 changed, 1 destroyed. No outputs found. The name of your deployment resource now includes a unique suffix. CDKTF adds this suffix to resources defined inside of constructs to ensure that each resource in the Terraform configuration it generates has a unique name. Use kubectl to report your deployment's status. kubectl get deployments NAME                 READY   UP-TO-DATE   AVAILABLE   AGE myapp-frontend-dev   2/2     2            2           5m14s Once Kubernetes deploys your app, kubectl will report two running replicas. Add a test Since your CDKTF application is written in TypeScript, you can use Jest to unit test it. First, configure Jest to work with CDKTF. Create a new file called jest.setup.js in the app directory with the following contents: jest.setup.js const cdktf require 'cdktf' cdktf Testing .setupJest () Note This filename ends in .js , not .ts , as required by Jest. Next, create a new file in the app/__tests__ directory named kubernetes-web-app-test.ts with the following contents. __tests__/kubernetes-web-app-test.ts import import { Testing } from import as kubernetes from import { KubernetesWebAppDeployment } from describe 'Our CDKTF Constructs' () => describe 'KubernetesWebAppDeployment' () => it 'should contain a deployment resource' () => expect Testing .synthScope ((scope) => new KubernetesWebAppDeployment (scope 'myapp-frontend-dev' image 'nginx:latest' replicas app 'myapp' component 'frontend' environment 'dev' }) }) .toHaveResource kubernetes deployment .Deployment) }) }) }) In your terminal, run your new test from the app/ directory. npm run test app@1.0.0 test jest PASS  __tests__/main-test.ts PASS  __tests__/kubernetes-web-app-test.ts Test Suites: 2 passed, 2 total Tests:       1 todo, 1 passed, 2 total Snapshots:   0 total Time:        5.109 s Ran all test suites. All of your tests should pass. There are more example tests in main-test.ts . CDKTF generates this file when you run cdktf init Add a NodePort Service The nginx:latest container is running in your deployment, but it is not accessible. Next you will add a NodePort Service to make it available on port 30001 Add NodePort Service construct In your editor, open app/constructs/kubernetes-web-app.ts Add a new interface for your NodePort Service right after the export interface KubernetesDeploymentConfig { ... } block. constructs/kubernetes-web-app.ts export interface KubernetesNodePortServiceConfig readonly port number readonly app string readonly component string readonly environment string Next, add a new KubernetesNodePortService construct after your KubernetesWebAppDeployment class, at the end of the file. constructs/kubernetes-web-app.ts export class KubernetesNodePortService extends Construct public readonly resource kubernetes service Service constructor scope Construct name string config KubernetesNodePortServiceConfig ) { super (scope name) this .resource new kubernetes service .Service this name metadata name ${ config .app ${ config .component ${ config .environment spec type 'NodePort' port port 80 targetPort '80' nodePort config .port protocol 'TCP' selector app config .app component config .component environment config .environment }) Test your construct Now open app/__tests__/kubernetes-web-app-test.ts and add a test. Near the top of the file, add your new KubernetesNodePortService to the import { ... } from '../constructs'; block, and include a comma after the KubernetesWebAppDeployment __tests__/kubernetes-web-app-test.ts import KubernetesWebAppDeployment KubernetesNodePortService from '../constructs' Add the test, inside the describe( block. This test must be on the same level as the describe( block. There will be a final }) at the end of the file after the new test. __tests__/kubernetes-web-app-test.ts describe 'KubernetesNodePortService' () => it 'should contain a Service resource' () => expect Testing .synthScope ((scope) => new KubernetesNodePortService (scope 'myapp-frontend-dev' app 'myapp' component 'frontend' environment 'dev' port 30001 }) }) .toHaveResource kubernetes service .Service) }) }) Check to make sure your tests still pass. Run the tests in the app/ directory. npm run test app@1.0.0 test jest PASS  __tests__/main-test.ts PASS  __tests__/kubernetes-web-app-test.ts Test Suites: 2 passed, 2 total Tests:       1 todo, 2 passed, 3 total Snapshots:   0 total Time:        5.094 s Ran all test suites. Jest should report that all of your tests pass. Add a NodePortService to your application In your editor, open app/main.ts , and a new import to the import { ... } from './constructs'; block near the top of the file with the following code, and include a comma after the KubernetesWebAppDeployment main.ts import KubernetesWebAppDeployment KubernetesNodePortService from './constructs' Add a new KubernetesNodePortService after your KubernetesWebAppDeployment , inside the constructor( ... ) { ... } function block. main.ts new KubernetesNodePortService this 'service' port 30001 app 'myapp' component 'frontend' environment 'dev' }) Deploy your application. Respond to the confirmation prompt by choosing Approve cdktf deploy app  Initializing the backend... app  Initializing provider plugins... app  - Reusing previous version of hashicorp/kubernetes from the dependency lock file app  - Using previously-installed hashicorp/kubernetes v2.14.0 app  Terraform has been successfully initialized! ##... Plan: 1 to add, 0 to change, 0 to destroy. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Saved the plan to: plan To perform exactly these actions, run the following command to apply: terraform apply Please review the diff output above for app Approve  Applies the changes outlined in the plan. Dismiss Stop ##... app  kubernetes_service.service_E7C408F2 (service/service): Creating... app  kubernetes_service.service_E7C408F2 (service/service): Creation complete after 0s [id=default/myapp-frontend-dev] app Apply complete! Resources: 1 added, 0 changed, 0 destroyed. No outputs found. Use kubectl to list your running services. kubectl get services NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE kubernetes           ClusterIP   10.96.0.1       <none>        443/TCP        101m myapp-frontend-dev   NodePort    10.96.186.212   <none>        80:30001/TCP   22s Kubectl reports two services, a ClusterIP service, and your new NodePort service. In may take a minute or two for the frontend to become available. When it is, curl will respond with the NGINX welcome page. curl http://localhost:30001 <!DOCTYPE html> <html> <head> <title>Welcome to nginx!</title> <style> html { color-scheme: light dark; } body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } </style> </head> <body> <h1>Welcome to nginx!</h1> <p>If you see this page, the nginx web server is successfully installed and working. Further configuration is required.</p> <p>For online documentation and support please refer to <a href= Commercial support is available at <a href= <p><em>Thank you for using nginx.</em></p> </body> </html> Open http://localhost:30001 in a new browser tab to review this page. Refactor your application Now you will refactor your application with a new CDKTF construct. Before you do so, remove the existing application to prevent the new application from attempting to use the same ports as the current one. Destroy app Like Terraform, you can use CDKTF to destroy the resources it manages. Before you refactor your code, destroy your application. Respond to the confirmation prompt by choosing Approve cdktf destroy app  Initializing the backend... app  Initializing provider plugins... app  - Reusing previous version of hashicorp/kubernetes from the dependency lock file app  - Using previously-installed hashicorp/kubernetes v2.14.0 app  Terraform has been successfully initialized! ##... Plan: 0 to add, 0 to change, 2 to destroy. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Saved the plan to: plan To perform exactly these actions, run the following command to apply: terraform apply Please review the diff output above for app Approve  Applies the changes outlined in the plan. Dismiss Stop app  kubernetes_service.service_E7C408F2 (service/service): Destroying... [id=default/myapp-frontend-dev] app  kubernetes_deployment.deployment_7B0B4E40 (deployment/deployment): Destroying... [id=default/myapp-frontend-dev] app  kubernetes_deployment.deployment_7B0B4E40 (deployment/deployment): Destruction complete after 0s app  kubernetes_service.service_E7C408F2 (service/service): Destruction complete after 0s app Destroy complete! Resources: 2 destroyed. Refactor constructs In your editor, open app/constructs/kubernetes-web-app.ts CDKTF provides classes and interfaces for built-in Terraform features, such as output values and functions. Add an import for Terraform outputs to the imports near the top of the file. constructs/kubernetes-web-app.ts import { TerraformOutput } from At the end of the file, add a new construct to represent an application, including a Deployment and a NodePortService. constructs/kubernetes-web-app.ts export type SimpleKubernetesWebAppConfig KubernetesWebAppDeploymentConfig KubernetesNodePortServiceConfig export class SimpleKubernetesWebApp extends Construct public readonly deployment KubernetesWebAppDeployment public readonly service KubernetesNodePortService public readonly config SimpleKubernetesWebAppConfig constructor scope Construct name string config SimpleKubernetesWebAppConfig ) { super (scope name) this .config config this .deployment new KubernetesWebAppDeployment this 'deployment' image config .image replicas config .replicas app config .app component config .component environment config .environment env config .env }) this .service new KubernetesNodePortService this 'service' port config .port app config .app component config .component environment config .environment }) new TerraformOutput this 'url' value `http://localhost: ${ config .port }) This new class also includes a Terraform output for the URL of your NodePort Service. Add a test for the SimpleKubernetesWebApp construct In your editor, add a test to app/__tests__/kubernetes-web-app-test.ts Add your SimpleKubernetesWebApp to the import { ... } from '../constructs'; block. __tests__/kubernetes-web-app-test.ts import KubernetesWebAppDeployment KubernetesNodePortService SimpleKubernetesWebApp from Add two new tests inside the describe('Our CDKTF Constructs', () => { ... }); block, on the same level as the describe('KubernetesWebAppDeployment', () => { ... }); block. __tests__/kubernetes-web-app-test.ts describe 'SimpleKubernetesWebApp' () => it 'should contain a Service resource' () => expect Testing .synthScope ((scope) => new SimpleKubernetesWebApp (scope 'myapp-frontend-dev' image 'nginx:latest' replicas app 'myapp' component 'frontent' environment 'dev' port 30001 }) }) .toHaveResource kubernetes service .Service) }) it 'should contain a Deployment resource' () => expect Testing .synthScope ((scope) => new SimpleKubernetesWebApp (scope 'myapp-frontend-dev' image 'nginx:latest' replicas app 'myapp' component 'frontent' environment 'dev' port 30001 }) }) .toHaveResource kubernetes deployment .Deployment) }) }) Run the tests Run the tests from the app/ directory. npm run test app@1.0.0 test jest PASS  __tests__/main-test.ts (6.019 s) PASS  __tests__/kubernetes-web-app-test.ts (8.059 s) Test Suites: 2 passed, 2 total Tests:       1 todo, 4 passed, 5 total Snapshots:   0 total Time:        8.556 s Ran all test suites. Use the SimpleKubernetesWebApp construct In your editor, update app/main.ts to import the SimpleKubernetesWebApp construct instead of the seperate Deployment and Service constructs. Replace the entire import { ... } from block with the following. main.ts import { SimpleKubernetesWebApp } from Remove the new KubernetesWebAppDeployment( ... ); and new KubernetesNodePortService( ... ); blocks from your constructor() function. Replace the old constructs with the new one: main.ts new SimpleKubernetesWebApp this 'app_frontend' image 'nginx:latest' replicas port 30001 app 'myapp' component 'frontend' environment 'dev' }) Deploy your application. Respond to the confirmation prompt by choosing Approve cdktf deploy app  Initializing the backend... app  Initializing provider plugins... app  - Reusing previous version of hashicorp/kubernetes from the dependency lock file app  - Using previously-installed hashicorp/kubernetes v2.14.0 app  Terraform has been successfully initialized! ##... Plan: 2 to add, 0 to change, 0 to destroy. Changes to Outputs: + app_frontend_url_5DD99814 = â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Saved the plan to: plan To perform exactly these actions, run the following command to apply: terraform apply Please review the diff output above for app Approve  Applies the changes outlined in the plan. Dismiss Stop app  kubernetes_service.app_frontend_service_C2863249 (app_frontend/service/service): Creating... app  kubernetes_deployment.app_frontend_deployment_0EE98C72 (app_frontend/deployment/deployment): Creating... app  kubernetes_service.app_frontend_service_C2863249 (app_frontend/service/service): Creation complete after 0s [id=default/myapp-frontend-dev] app  kubernetes_deployment.app_frontend_deployment_0EE98C72 (app_frontend/deployment/deployment): Creation complete after 4s [id=default/myapp-frontend-dev] app Apply complete! Resources: 2 added, 0 changed, 0 destroyed. app Outputs: app_frontend_url_5DD99814 = app app_frontend url = http://localhost:30001 Notice that after you refactored your applications resources using constructs, CDKTF assigned the resources new names. Because the names have changed, Terraform will treat them as new resources. If you had not destroyed the old application first, then Terraform would attempt to provision the new resources before destroying the old ones. Since both services use the port 30001 , this would result in a port conflict error from Kubernetes. List your running services with the kubectl command. kubectl get services NAME                 TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE kubernetes           ClusterIP   10.96.0.1      <none>        443/TCP        142m myapp-frontend-dev   NodePort    10.96.216.88   <none>        80:30001/TCP   44s After Kubernetes is finished deploying your application, curl will once again respond with the NGINX welcome page: curl http://localhost:30001 <!DOCTYPE html> <html> <head> <title>Welcome to nginx!</title> <style> html { color-scheme: light dark; } body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } </style> </head> <body> <h1>Welcome to nginx!</h1> <p>If you see this page, the nginx web server is successfully installed and working. Further configuration is required.</p> <p>For online documentation and support please refer to <a href= Commercial support is available at <a href= <p><em>Thank you for using nginx.</em></p> </body> </html> Visit this URL in your web browser to confirm that your application still works as expected after refactoring your code. Deploy a custom image Now you will deploy a custom image to your application's frontend. Build frontend docker image Navigate to the frontend directory. cd ../frontend This directory contains Terramino, a Terraform-skinned Tetris game, which you will deploy as a Docker container. Build a Docker image for your web app: docker build -t nocorp-frontend [+] Building 33.0s (12/12) FINISHED => [internal] load build definition from Dockerfile                                                                              0.0s => => transferring dockerfile: 295B                                                                                              0.0s => [internal] load .dockerignore                                                                                                 0.0s => => transferring context: 67B                                                                                                  0.0s => [internal] load metadata for docker.io/library/node:14                                                                        1.3s => [1/7] FROM docker.io/library/node:14@sha256:109b118e0d49dd12ca6f5b84a7a9a9c8a147f75567b3ad50620bdacaf5e6320d                 26.2s ## ... => [internal] load build context                                                                                                 0.0s => => transferring context: 718.44kB                                                                                             0.0s => [2/7] WORKDIR /usr/share/app                                                                                                  0.2s => [3/7] COPY package*.json ./                                                                                                   0.0s => [4/7] COPY frontend.js ./                                                                                                     0.0s => [5/7] COPY public/ ./public/                                                                                                  0.0s => [6/7] COPY views/ ./views/                                                                                                    0.0s => [7/7] RUN npm install                                                                                                         4.8s => exporting to image                                                                                                            0.2s => => exporting layers                                                                                                           0.2s => => writing image sha256:9dc1ce3668a79770f694ddeae6a5c2236527c381cd429d850eb4a37a8c565ce1                                      0.0s => => naming to docker.io/library/nocorp-frontend                                                                                0.0s Use 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them Tag your image in the local Docker registry. docker tag nocorp-frontend:latest localhost:5000/nocorp-frontend:latest Push your image to the registry. docker push localhost:5000/nocorp-frontend:latest The push refers to repository [localhost:5000/nocorp-frontend] 72d21ab0ed02: Pushed a831dca05db6: Pushed 66018b4c7669: Pushed 65f4bcfe9daa: Pushed add6fa0cc975: Pushed 8628cf05347a: Pushed 85bfe2c7cf32: Pushed 28e2f0d3695c: Pushed b892edc3d92e: Pushed f1486e967e48: Pushed 5750262417ad: Pushed 9ed3c35b4335: Pushed 6f7f3f280040: Pushed d6e0d602719c: Pushed 73c3e7ef7bc6: Pushed latest: digest: sha256:f56babe32077523e891b24af0e38fe00026c7f8ed38b89d90a102aaeeb3d40b8 size: 3465 Now your application's frontend is available as a Docker container that your Kubernetes instance can deploy. Use new frontend image In your editor, open app/main.ts , and replace the image parameter with the location of your new image. app/main.ts new SimpleKubernetesWebApp this 'app_frontend' image 'localhost:5000/nocorp-frontend:latest' replicas port 30001 app 'myapp' component 'frontend' environment 'dev' }); In your terminal, return to the app directory. cd ../app Deploy your new frontend with the new image. Respond to the confirmation prompt with a yes cdktf deploy app  Initializing the backend... app  Initializing provider plugins... app  - Reusing previous version of hashicorp/kubernetes from the dependency lock file app  - Using previously-installed hashicorp/kubernetes v2.14.0 Terraform has been successfully initialized! ##... app  Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols: ~ update in-place Terraform will perform the following actions: app    # kubernetes_deployment.app_frontend_deployment_0EE98C72 (app_frontend/deployment/deployment) will be updated in-place ~ resource id               = # (1 unchanged attribute hidden) ~ spec { # (5 unchanged attributes hidden) ~ template { ~ spec { # (11 unchanged attributes hidden) ~ container { ~ image                      = name                       = # (8 unchanged attributes hidden) ##... Plan: 0 to add, 1 to change, 0 to destroy. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Saved the plan to: plan To perform exactly these actions, run the following command to apply: terraform apply Please review the diff output above for app Approve  Applies the changes outlined in the plan. Dismiss Stop ##... app  kubernetes_deployment.app_frontend_deployment_0EE98C72 (app_frontend/deployment/deployment): Modifying... [id=default/myapp-frontend-dev] app  kubernetes_deployment.app_frontend_deployment_0EE98C72 (app_frontend/deployment/deployment): Still modifying... [id=default/myapp-frontend-dev, 10s elapsed] app  kubernetes_deployment.app_frontend_deployment_0EE98C72 (app_frontend/deployment/deployment): Still modifying... [id=default/myapp-frontend-dev, 20s elapsed] app  kubernetes_deployment.app_frontend_deployment_0EE98C72 (app_frontend/deployment/deployment): Modifications complete after 25s [id=default/myapp-frontend-dev] app Apply complete! Resources: 0 added, 1 changed, 0 destroyed. Outputs: app  app_frontend_url_5DD99814 = app app_frontend url = http://localhost:30001 Kubernetes will take a few minutes to deploy the new container image. Use kubectl to check your deployment's status. kubectl get deployments NAME                 READY   UP-TO-DATE   AVAILABLE   AGE myapp-frontend-dev   3/3     3            3           43s Once all three replicas are up-to-date, curl will respond with a Terramino page instead of the NGINX welcome page. curl http://localhost:30001 <!DOCTYPE html><html><head><title>Terranimo</title></head><link rel= Visit http://localhost:30001 to review the application. The app will display an error, because you have not yet deployed the backend server. Add a backend service Now you will deploy a backend component to your application, using the SimpleKubernetesWebApp construct. Build backend image In your terminal, navigate to the backend directory. cd ../backend Use NPM to build and push the Docker image for your application backend. npm run deploy nocorp-backend-app@1.0.0 deploy /Users/ YOU /code/learn-terraform-cdktf-applications/backend npm run build && npm run tag && npm run push nocorp-backend-app@1.0.0 build /Users/ YOU /code/learn-terraform-cdktf-applications/backend docker build -t nocorp-backend ## ... The push refers to repository [localhost:5000/nocorp-backend] 676744aedcf3: Pushed e64b93b2c9bd: Pushed 8628cf05347a: Mounted from nocorp-frontend 85bfe2c7cf32: Mounted from nocorp-frontend 28e2f0d3695c: Mounted from nocorp-frontend b892edc3d92e: Mounted from nocorp-frontend f1486e967e48: Mounted from nocorp-frontend 5750262417ad: Mounted from nocorp-frontend 9ed3c35b4335: Mounted from nocorp-frontend 6f7f3f280040: Mounted from nocorp-frontend d6e0d602719c: Mounted from nocorp-frontend 73c3e7ef7bc6: Mounted from nocorp-frontend latest: digest: sha256:845e60dd8350066a89757f1bdb200584f317e5b15d68cc9609a3c359f3736676 size: 2841 This command automatically ran the same build, tag, and push steps that you ran manually for your frontend image. In your editor, open app/main.ts , and add a new SimpleKubernetesWebApp immediately before the new SimpleKubernetesWebApp(this, 'app_frontend', { ... }); block. main.ts const app_backend new SimpleKubernetesWebApp this 'app_backend' image 'localhost:5000/nocorp-backend:latest' replicas port 30002 app 'myapp' component 'backend' environment 'dev' }) Your application's frontend needs access to the backend's URL. Update the frontend block in app/main.ts to pass this as an environment variable. main.ts new SimpleKubernetesWebApp this 'app_frontend' image 'localhost:5000/nocorp-frontend:latest' replicas port 30001 app 'myapp' component 'frontend' environment 'dev' env { BACKEND_APP_URL `http://localhost: ${ app_backend config .port }) In your terminal, return to the app directory. cd ../app Deploy your new backend. Respond to the confirmation prompt with a yes cdktf deploy app  Initializing the backend... app  Initializing provider plugins... - Reusing previous version of hashicorp/kubernetes from the dependency lock file app  - Using previously-installed hashicorp/kubernetes v2.14.0 Terraform has been successfully initialized! ##... app  Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols: + create ~ update in-place Terraform will perform the following actions: app    # kubernetes_deployment.app_backend_deployment_1A8B5520 (app_backend/deployment/deployment) will be created + resource ##... # kubernetes_deployment.app_frontend_deployment_0EE98C72 (app_frontend/deployment/deployment) will be updated in-place ~ resource id               = ##... + env { + name  = + value = ##... # kubernetes_service.app_backend_service_EAD583EF (app_backend/service/service) will be created + resource ##... Plan: 2 to add, 1 to change, 0 to destroy. Changes to Outputs: + app_backend_url_CAA2B50B = â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Saved the plan to: plan To perform exactly these actions, run the following command to apply: terraform apply Please review the diff output above for app Approve  Applies the changes outlined in the plan. Dismiss Stop ##... app  kubernetes_service.app_backend_service_EAD583EF (app_backend/service/service): Creating... app  kubernetes_deployment.app_backend_deployment_1A8B5520 (app_backend/deployment/deployment): Creating... app  kubernetes_deployment.app_frontend_deployment_0EE98C72 (app_frontend/deployment/deployment): Modifying... [id=default/myapp-frontend-dev] app  kubernetes_service.app_backend_service_EAD583EF (app_backend/service/service): Creation complete after 0s [id=default/myapp-backend-dev] app  kubernetes_deployment.app_backend_deployment_1A8B5520 (app_backend/deployment/deployment): Creation complete after 1s [id=default/myapp-backend-dev] app  kubernetes_deployment.app_frontend_deployment_0EE98C72 (app_frontend/deployment/deployment): Modifications complete after 3s [id=default/myapp-frontend-dev] app Apply complete! Resources: 2 added, 1 changed, 0 destroyed. Outputs: app_backend_url_CAA2B50B = app_frontend_url_5DD99814 = app app_backend url = http://localhost:30002 app_frontend url = http://localhost:30001 It may take Kubernetes a few minutes to deploy your new resources. Use kubectl to check the status. kubectl get deployments NAME                 READY   UP-TO-DATE   AVAILABLE   AGE myapp-backend-dev    1/1     1            1           57s myapp-frontend-dev   3/3     3            3           15m Once your kubectl reports all four replicas as ready (three myapp-frontend-dev and one myapp-backend-dev ), your application will be available. Visit your application's frontend URL ( http://localhost:30001 ) in your web browser. You may need to reload the page for the application to work. You can also use curl to interact directly with the backend server: curl http://localhost:30002/new Deploy another application stack CDKTF projects can support multiple application stacks. Each CDKTF Stack is a separate Terraform project that you can manage independently. So far in this tutorial, you have deployed your resources as a single stack. In this section, you will deploy a new copy of your application as a new stack representing a test environment. Refactor application stack Currently, your stack's frontend and backend services are configured using hard-coded values that you pass to SimpleKubernetesWebApp in main.ts Refactor your MyApp stack to accept your application's configuration as an argument instead of hard-coding it in the constructor() function. In your editor, open app/main.ts , and add the SimpleKubernetesWebAppConfig interface to your list of imports near the top of the file. main.ts import SimpleKubernetesWebApp SimpleKubernetesWebAppConfig from Next, update the class's constructor to accept two SimpleKubernetesWebAppConfig objects, and pass them to your frontend and backend. Replace the entire class MyStack extends TerraformStack { ... } block with the following. main.ts class MyStack extends TerraformStack constructor scope Construct name string config frontend SimpleKubernetesWebAppConfig backend SimpleKubernetesWebAppConfig ) { super (scope name) new kubernetes provider .KubernetesProvider this 'kind' configPath path .join (__dirname '../kubeconfig.yaml' }) const app_backend new SimpleKubernetesWebApp this 'app_backend' config .backend new SimpleKubernetesWebApp this 'app_frontend' ... config .frontend env { BACKEND_APP_URL `http://localhost: ${ app_backend config .port }) Finally, pass these configuration objects when you create your application object near the end of the file. Replace the current new MyStack... line with the following, immediately before the last line, app.synth(); main.ts const app new App () new MyStack (app 'app' frontend image 'localhost:5000/nocorp-frontend:latest' replicas port 30001 app 'myapp' component 'frontend' environment 'dev' backend image 'localhost:5000/nocorp-backend:latest' replicas port 30002 app 'myapp' component 'backend' environment 'dev' }) app .synth () In your terminal, run cdktf deploy . Since the Terraform configuration generated by CDKTF has not changed, there will be no changes to deploy. cdktf deploy app  Initializing the backend... app  Initializing provider plugins... - Reusing previous version of hashicorp/kubernetes from the dependency lock file app  - Using previously-installed hashicorp/kubernetes v2.14.0 app  Terraform has been successfully initialized! ##... app  No changes. Your infrastructure matches the configuration. app  Terraform has compared your real infrastructure against your configuration and found no differences, so no changes are needed. app app_frontend url = http://localhost:30001 app_backend url = http://localhost:30002 Add a second stack Now, add a second stack to main.ts to represent your test environment, immediately before the last line, app.synth(); main.ts new MyStack (app 'app-test' frontend image 'localhost:5000/nocorp-frontend:latest' replicas port 30003 app 'myapp' component 'frontend' environment 'test' backend image 'localhost:5000/nocorp-backend:latest' replicas port 30004 app 'myapp' component 'backend' environment 'test' }) Now that your project contains more than one stack, you must specify a stack when you run CDKTF commands. Deploy your new stack. Respond to the confirmation prompt by choosing Approve cdktf deploy app-test app-test  Initializing the backend... app-test Successfully configured the backend use this backend unless the backend configuration changes. app-test  Initializing provider plugins... - Finding hashicorp/kubernetes versions matching app-test  - Using hashicorp/kubernetes v2.14.0 from the shared cache directory app-test  Terraform has created a lock file .terraform.lock.hcl to record the provider selections it made above. Include this file in your version control repository so that Terraform can guarantee to make the same selections by default when you run ##... Please review the diff output above for app Approve  Applies the changes outlined in the plan. Dismiss Stop ##... app-test  kubernetes_service.app_frontend_service_C2863249 (app_frontend/service/service): Creating... kubernetes_service.app_backend_service_EAD583EF (app_backend/service/service): Creating... app-test  kubernetes_deployment.app_backend_deployment_1A8B5520 (app_backend/deployment/deployment): Creating... app-test  kubernetes_deployment.app_frontend_deployment_0EE98C72 (app_frontend/deployment/deployment): Creating... app-test  kubernetes_service.app_frontend_service_C2863249 (app_frontend/service/service): Creation complete after 0s [id=default/myapp-frontend-test] app-test  kubernetes_service.app_backend_service_EAD583EF (app_backend/service/service): Creation complete after 0s [id=default/myapp-backend-test] app-test  kubernetes_deployment.app_frontend_deployment_0EE98C72 (app_frontend/deployment/deployment): Creation complete after 8s [id=default/myapp-frontend-test] app-test  kubernetes_deployment.app_backend_deployment_1A8B5520 (app_backend/deployment/deployment): Creation complete after 8s [id=default/myapp-backend-test] app-test Apply complete! Resources: 4 added, 0 changed, 0 destroyed. app-test Outputs: app_backend_url_CAA2B50B = app_frontend_url_5DD99814 = app-test app_backend url = http://localhost:30004 app_frontend url = http://localhost:30003 Since each stack is a separate Terraform project with separate state, you can deploy, update, and destroy them independently. Confirm that kubernetes has deployed your test stack's frontend and backend with kubectl. kubectl get deployments NAME                  READY   UP-TO-DATE   AVAILABLE   AGE myapp-backend-dev     1/1     1            1           46m myapp-backend-test    2/2     2            2           71s myapp-frontend-dev    3/3     3            3           60m myapp-frontend-test   4/4     4            4           71s This command will list both your Clean up resources In this section, you will delete your CDKTF application stacks, your kind cluster, and your local Docker image registry. Destroy your app-test stack. Respond to the confirmation prompt by choosing Approve cdktf destroy app-test app-test  Initializing the backend... app-test  Initializing provider plugins... - Reusing previous version of hashicorp/kubernetes from the dependency lock file app-test  - Using previously-installed hashicorp/kubernetes v2.14.0 app-test  Terraform has been successfully initialized! ##... Plan: 0 to add, 0 to change, 4 to destroy. app-test Changes to Outputs: - app_backend_url_CAA2B50B  = - app_frontend_url_5DD99814 = â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Saved the plan to: plan To perform exactly these actions, run the following command to apply: terraform apply Please review the diff output above for app-test Approve  Applies the changes outlined in the plan. Dismiss Stop ##... app-test  kubernetes_service.app_backend_service_EAD583EF (app_backend/service/service): Destruction complete after 0s app-test  kubernetes_service.app_frontend_service_C2863249 (app_frontend/service/service): Destruction complete after 0s app-test Destroy complete! Resources: 4 destroyed. Next, destroy your app stack. Respond to the confirmation prompt by choosing Approve cdktf destroy app app  Initializing the backend... app  Initializing provider plugins... - Reusing previous version of hashicorp/kubernetes from the dependency lock file app  - Using previously-installed hashicorp/kubernetes v2.12.1 app  Terraform has been successfully initialized! ##... Plan: 0 to add, 0 to change, 4 to destroy. Changes to Outputs: - app_frontend_url_FE3D723A = - app_backend_url_91B41C22   = â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Saved the plan to: plan To perform exactly these actions, run the following command to apply: terraform apply Please review the diff output above for app Approve  Applies the changes outlined in the plan. Dismiss Stop ##... app  kubernetes_service.app_backend_service_EAD583EF (app_backend/service/service): Destruction complete after 0s app  kubernetes_service.app_frontend_service_C2863249 (app_frontend/service/service): Destruction complete after 0s app Destroy complete! Resources: 4 destroyed. Delete your kind cluster. kind delete cluster --name=cdktf-app Deleting cluster Stop your local registry Docker container. docker stop local-registry local-registry Remove the container. docker rm local-registry local-registry Next steps In this tutorial, you used the CDK for Terraform to deploy an application to a local Kubernetes cluster. You used CDK Constructs to refactor your application, and deployed multiple copies of your entire application as separate stacks. Learn more about how to use the CDK for Terraform to manage Terraform projects by reviewing the following resources: Follow the other CDKTF tutorials Find more examples and documentation in the CDKTF documentation Learn how the Mozilla Pocket team uses the CDK for Terraform to deploy applications on Amazon ECS. Was this tutorial helpful? Previous Lambda functions Next Collection Community Providers"
    },
    {
      "heading": "9 tutorials",
      "level": 2,
      "prose": "Deploy and Monitor Applications Deploy, release, and monitor applications using Terraform. Host a static website with Cloudflare, roll out new releases with the help of load balancers, and monitor applications with Datadog, managed with Terraform configurations. Terraform On this page: Deploy an application with CDK for Terraform Prerequisites Clone example repository Initialize your CDKTF application Create a Kubernetes Deployment Refactor your deployment Add a NodePort Service Add a NodePortService to your application Refactor your application Run the tests Use the SimpleKubernetesWebApp construct Deploy a custom image Add a backend service Deploy another application stack Clean up resources Next steps"
    }
  ],
  "images": [],
  "tabVariants": {}
}